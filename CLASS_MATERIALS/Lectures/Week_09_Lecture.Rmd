---
title: "GLMs and Poisson regression"
author: "Peter Ralph"
date: "26 November 2019 -- Advanced Biological Statistics"
---

```{r setup, include=FALSE}
fig.dim <- 4
knitr::opts_chunk$set(fig.width=2*fig.dim,
                      fig.height=fig.dim,
                      fig.align='center')
set.seed(23)
library(tidyverse)
library(rstan)
library(matrixStats)
options(mc.cores = parallel::detectCores())
```


# Math minute: matrix multiplication

## 

To simulate from:
$$\begin{aligned}
    \mu_i &= b_0 + b_1 X_{i1} + \cdots + b_k X_{ik} \\
    Y_i &\sim \Normal(\mu_i, \sigma) .
\end{aligned}$$

either

```{r simdata_mv}
coefs <- list(b0=1.0, b=c(3.0, -1.0, 0.0, 0.0),
              sigma=0.5)
n <- 200
X <- matrix(rnorm(4*n, mean=0, sd=3), ncol=4)
Y <- coefs$b0 
for (k in 1:ncol(X)) {
    Y <- Y + coefs$b[k] * X[,k]
}
Y <- Y + rnorm(n, mean=0, sd=coefs$sigma)
```

##

To simulate from:
$$\begin{aligned}
    \mu_i &= b_0 + b_1 X_{i1} + \cdots + b_k X_{i1} \\
    Y_i &\sim \Normal(\mu_i, \sigma) .
\end{aligned}$$

of

```{r simdata_mv2}
coefs <- list(b0=1.0, b=c(3.0, -1.0, 0.0, 0.0),
              sigma=0.5)
n <- 200
X <- matrix(rnorm(4*n, mean=0, sd=3), ncol=4)
Y <- coefs$b0 + X %*% coefs$b + rnorm(n, mean=0, sd=coefs$sigma)
```

## Because

In R, `%*%` is *matrix multiplication*: if

- $b$ is a $k$-vector
- $X$ is an $n \times k$ matrix

then `X %*% b` (or, $X b$ in math notation) is shorthand for the $n$-vector
$$ (Xb)_i = \sum_{j=1}^k X_{ij} b_j . $$

<!-- NOTE:
    Pictures on the board.
-->


. . .

In Stan, matrix multiplication is `*`.


# A note on impostor syndrome

-------

![](images/impostor_penguin.jpeg)

-------

![](images/neil_gaiman_impostor_syndrome.png)

# Generalized Linear Models

## Ingredients of a GLM:

1. A probability distribution, $Y$.

  > *(the "family"; describes the output)*

2. A linear predictor, $X \beta$.

  > *(connects input to output)*

3. A link function, $\E[Y] = h(X\beta)$.

  > *(connects linear predictor to probability distribution)*

## Common choices:

- Linear regression:
  $$ Y \sim \Normal(X \beta, \sigma) .$$

- Logistic regression:
  $$ Y \sim \Binom(n, \logistic(X\beta)) .$$

- Gamma regression:
  $$ Y \sim \Gam(\text{scale}=\exp(X\beta)/k, \text{shape}=k) .$$

## Logistic regression, in R

```
glm(y ~ x, family=binomial)
```

. . .

```
family {stats}

Family objects provide a convenient way to specify the details of the models
used by functions such as glm.

binomial(link = "logit")
gaussian(link = "identity")
Gamma(link = "inverse")
inverse.gaussian(link = "1/mu^2")
poisson(link = "log")

Arguments

link: a specification for the model link function. This can be a
name/expression, a literal character string, a length-one character vector, or
an object of class "link-glm" (such as generated by make.link) provided it is
not specified via one of the standard names given next.

The gaussian family accepts the links (as names) identity, log and inverse; the
binomial family the links logit, probit, cauchit, (corresponding to logistic,
normal and Cauchy CDFs respectively) log and cloglog (complementary log-log);
the Gamma family the links inverse, identity and log; the poisson family the
links log, identity, and sqrt; and the inverse.gaussian family the links
1/mu^2, inverse, identity and log.
```

# Unpacking logistic regression

## Simulate data

100 trials, where probability of success depends on $x$:
```{r sim_logistic, fig.width=2*fig.dim}
alpha <- -7; beta <- 1.2
x <- runif(100, 0, 10)
y <- alpha + beta * x
p <- 1 / (1 + exp(-y))
z <- rbinom(100, size=1, prob=p)
plot(z ~ x)
curve(1/(1+exp(-(-7 + 1.2 *x))), 0, 10, col='red', add=TRUE)
```

## `glm()`

```{r run_glm}
zz <- cbind(z, 1-z)
summary(glm_fit <- glm(zz ~ x, family='binomial'))
```

## Stan

::: {.columns}
:::::: {.column width=50%}

$$\begin{aligned}
    Z &\sim \Binom(1, P) \\
    P &= \logistic(\alpha + \beta X)
\end{aligned}$$

:::
:::::: {.column width=50%}


```{r stan_logistic, cache=TRUE}
logistic_block <- "
data {
    int N;
    vector[N] X;
    int<lower=0> Z[N];
}
parameters {
    real alpha;
    real beta;
}
model {
    vector[N] p;
    p = inv_logit(alpha + beta * X);
    Z ~ binomial(1, p);
}"
```

:::
::::::

## Stan: fit the model

```{r run_stan_logistic, cache=TRUE, dependson="stan_logistic"}
fit <- stan(model_code=logistic_block,
            data=list(N=100, X=x, Z=z))
rstan::summary(fit)$summary
```

## Stan: posterior distributions

```{r plot_stan_logistic, fig.width=2*fig.dim}
samples <- extract(fit)
layout(t(1:2))
hist(samples$alpha, main=expression(alpha))
abline(v=alpha, col='red'); abline(v=coef(glm_fit)[1], col='green')
hist(samples$beta, main=expression(beta))
abline(v=beta, col='red'); abline(v=coef(glm_fit)[2], col='green')
legend("topright", lty=1, col=c('red', 'green'), legend=c('truth', 'glm'))
```

# Identify the GLM

## 

::: {.columns}
:::::: {.column width=60%}

```
data {
  int N;
  vector[N] X;
  vector[N] Y;
  vector<lower=0> Z[N];
}
parameters {
  real beta[2];
}
model {
  Z ~ gamma(1, exp(- beta[1] * X - beta[2] * Y));
}
```

:::
:::::: {.column width=40%}

What is

1. the probability distribution?
  *(describes the output)*

2. the linear predictor?
  *(connects input to output)*

3. the link function?
  *(connects linear predictor to probability distribution)*


**Then,** simulate from it.

:::
::::::

## in class

```{r siminclass}
N <- 100
# Matrix of X, Y
XY <- cbind(X=rnorm(N), 
            Y=rnorm(N))
beta <- c(2, -3)
# Xbeta <- beta[1] * X + beta[2] * Y
Xbeta <- XY %*% beta
Z <- rgamma(N, shape=1, scale=exp(-Xbeta))

gZ <- glm(Z ~ XY[,"X"] + XY[,"Y"], family=Gamma(link='log'))
summary(gZ)

plot(Xbeta, Z)

```


# Stochastic minute

## The Poisson distribution

If $N \sim \Poisson(\mu)$ then $N \ge 0$ and
$$\begin{aligned}
    \P\{N = k\} = \frac{\mu^k}{k!} e^{-\mu}
\end{aligned}$$

- $N$ is a nonnegative integer (i.e., a *count*)

- $\E[N] = \var[N] = \mu$

- If a machine makes widgets very fast,
  producing on average one broken widget per minute (and many good ones),
  each breaking independent of the others,
  then the number of broken widgets in $\mu$ minutes is $\Poisson(\mu)$.

- If busses arrive randomly every $\Exp(1)$ minutes,
  then the number of busses to arrive in $\mu$ minutes
  is $\Poisson(\mu)$.



# Count data

## A hypothetical situation:

1. We have **counts** of transcript numbers,

2. from some individuals of different **ages**
   and past **exposures** to solar irradiation,

3. of two **genotypes**.

. . .

*Model:*

* Counts are **Poisson**,

* with mean that depends on age and exposure,

* but effect of exposure depends on genotype.



-------------------------

::: {.columns}
::::::::: {.column width="50%"}


1. Counts are **Poisson**,

2. with mean that depends on age and exposure,

3. but effect of exposure depends on genotype.

:::
:::::::::: {.column width="50%"}


$$\begin{aligned}
    Z_i &\sim \Poisson(\mu_i) \\
\end{aligned}$$

:::
:::::::::::



-------------------------

::: {.columns}
::::::::: {.column width="50%"}


1. Counts are **Poisson**,

2. with mean that depends on age and exposure,

3. but effect of exposure depends on genotype.

:::
:::::::::: {.column width="50%"}


$$\begin{aligned}
    Z_i &\sim \Poisson(\mu_i) \\
    \mu_i &= a + b \times \text{age}_i + c \times \text{exposure}_i 
\end{aligned}$$

:::
:::::::::::



-------------------------

::: {.columns}
::::::::: {.column width="50%"}


1. Counts are **Poisson**,

2. with mean that depends on age and exposure,

3. but effect of exposure depends on genotype.

:::
:::::::::: {.column width="50%"}


$$\begin{aligned}
    Z_i &\sim \Poisson(\mu_i) \\
    \mu_i &= \exp\left( a_{g_i} + b \times \text{age}_i + c_{g_i} \times \text{exposure}_i \right)
\end{aligned}$$

:::
:::::::::::

# Poisson regression, in practice

## The data


```{r sim_counts, include=FALSE, cache=TRUE}
true_params <- list(a=c(0, 0.2),
                    b=1/20,
                    c=c(1/30, -1/15),
                    sigma=1.0)
nsamples <- 500
data <- data.frame(genotype=sample(c(1,2), nsamples, 
                                   replace=TRUE),
                   age = rgamma(nsamples, 3, 0.1),
                   exposure = rexp(nsamples, 0.2))
data$y <- with(data, true_params$a[genotype] +
                      true_params$b * age +
                      true_params$c[genotype] * exposure)
data$mu <- exp(rnorm(nrow(data), mean=data$y, 
                     sd=true_params$sigma))
data$counts <- rpois(nsamples, data$mu)
```

```{r save_data, include=FALSE}
write.table(data, file="poisson_counts_data.tsv", row.names=FALSE)
write.table(data[,c(1,2,3,6)], file="poisson_counts.tsv", row.names=FALSE)
```

```{r plot_counts, echo=FALSE, fig.width=2*fig.dim}
layout(t(1:2))
plot(counts ~ age, col=genotype, data=data, pch=20)
plot(counts ~ exposure, col=genotype, data=data, pch=20)
legend("topright", pch=20, col=1:2,
       legend=paste("genotype", 1:2))
```

## Your turn: use `glm( )`


$$\begin{aligned}
    Z_i &\sim \Poisson(\mu_i) \\
    \mu_i &= \exp\left( a_{g_i} + b \times \text{age}_i + c_{g_i} \times \text{exposure}_i \right)
\end{aligned}$$


Here are [the data](poisson_counts.tsv):
```{r show_data}
countdata <- read.table("poisson_counts.tsv", header=TRUE)
head(countdata)
```

## Write a Stan block

::: {.columns}
::::::::: {.column width="50%"}


1. Counts are **Poisson**,

2. with mean that depends on age and exposure,

3. but effect of exposure depends on genotype.

$$\begin{aligned}
    Z_i &\sim \Poisson(y_i) \\
    y_i &= \exp(a_{g_i} + b \times \text{age}_i \\
        &\qquad {} + c_{g_i} \times \text{exposure}_i )
\end{aligned}$$

:::
:::::::::: {.column width="50%"}

<!-- 
    NOTE: do this online, asking class what needs to be included
    and walking through how to include it 
-->

```
data {
    int N;
    int counts[N];
    vector[N] age;
    vector[N] exposure;
    int genotype[N];
    int ngeno;
}
parameters {
    real a[ngeno]; // intercepts
    real b; // slope for age
    real c[ngeno]; // slopes for exposure
}
model {
    vector[N] y; // means
    y = exp(a[genotype] + b .* age + c[genotype] .* exposure);
    counts ~ poisson(y);
    // implicitly flat priors
}
```

:::
:::::::::::


## The result

*Note:* scaling the data helps Stan find the right scale to move on.

```{r run_simple_pois, cache=TRUE, dependson=c("sim_counts", "simple_poisson")}
scaled_data <- with(data, list(N=length(counts),
                               counts=counts,
                               age=(age - mean(age))/sd(age),
                               expo=(exposure - mean(exposure))/sd(exposure),
                               geno=genotype))
fit1 <- stan(file="simple_poisson.stan",
             data=scaled_data,
             control=list(max_treedepth=12),
             iter=1000, chains=3)
```

-----------

```{r printit}
post1 <- extract(fit1)
print(fit1)
```

## 

```{r not_warmup}
stan_trace(fit1, pars=c("a","b","c","lp__"), inc_warmup=FALSE)
```

## How'd we do?

Here are posterior distributions of the parameters,
with **the true values in red**.
```{r true_fit_1, echo=FALSE}
# a[g] + b * (age - ma)/sa + c[g] * (exp - me)/se
# = a[g] - b * ma / sa - c[g] * me / se + (b/sa) * age  + (c[g]/se) * exp
post1$true_a <- with(data, post1$a - cbind(post1$b,post1$b) * mean(age)/sd(age) - post1$c * mean(exposure)/sd(exposure))
layout(matrix(1:6, nrow=2, byrow=TRUE))
with(data, {
    hist(post1$true_a[,1], breaks=50, main='a[1]', 
         xlim=range(post1$true_a[,1], true_params$a[1]))
    abline(v=true_params$a[1], col='red', lwd=2)
    hist(post1$true_a[,2], breaks=50, main='a[2]',
         xlim=range(post1$true_a[,2], true_params$a[2]))
    abline(v=true_params$a[2], col='red', lwd=2)
    hist(post1$b/sd(age), breaks=50, main='b',
         xlim=range(true_params$b, post1$b/sd(age)))
    abline(v=true_params$b, col='red', lwd=2)
    hist(post1$c[,1]/sd(exposure), breaks=50, main='c[1]',
         xlim=range(post1$c[,1]/sd(exposure), true_params$c[1]))
    abline(v=true_params$c[1], col='red', lwd=2)
    hist(post1$c[,2]/sd(exposure), breaks=50, main='c[2]',
         xlim=range(post1$c[,2]/sd(exposure), true_params$c[2]))
    abline(v=true_params$c[2], col='red', lwd=2)
 })
```

. . .

*What happened?*

# Goodness of fit

## Posterior predictive simulations

Let's simulate up data *under this model* to check for goodness of fit.

. . .

We expect to **not** see a good fit. (*Why?*)


## 100 datasets from the posterior distribution


::: {.columns}
:::::::: {.column width="60%"}

```{r post_sims1}
params1 <- list(a=colMeans(post1$a),
                b=mean(post1$b),
                c=colMeans(post1$c))
mu1 <- with(list2env(scaled_data), 
                exp(params1$a[geno] 
                    + params1$b * age
                    + params1$c[geno] * expo))
# 100 datasets:
sim1 <- replicate(100, rpois(length(mu1), mu1))
```

:::
:::::::::: {.column width="40%"}

```
model {
    vector[N] mu;
    mu = exp(a[geno] 
             + b * age 
             + c[geno] 
               .* expo);
    counts ~ poisson(mu);
```

:::
:::::::::::

## True data are *overdispersed* relative to our simulations

```{r plot_post_sims1}
plot(data$counts[order(mu1)], ylab="counts", ylim=range(sim1), type='n')
segments(x0=seq_len(nrow(data)),
         y0=rowMins(sim1)[order(mu1)],
         y1=rowMaxs(sim1)[order(mu1)])
points(data$counts[order(mu1)], pch=20, col='red')
legend("topleft", pch=c(20,NA), lty=c(NA,1), legend=c("observed", "simulated range"), col=c('red', 'black'))
```


# Stan interlude

## The important program blocks

```
data {
    // what we know: the input
    // declarations only
}
parameters {
    // what we want to know about:
    // defines the space Stan random walks in
    // declarations only
}
model {
    // stuff to calculate the priors and the likelihoods
    // happens every step
}
```


## The program blocks

```
functions {
    // user-defined functions
}
data {
    // what we know: the input
    // declarations only
}
transformed data {
    // calculations to do once, at the start
}
parameters {
    // what we want to know about:
    // defines the space Stan random walks in
    // declarations only
}
transformed parameters {
    // other things that we want the posterior distribution of
    // happens every step
}
model {
    // stuff to calculate the priors and the likelihoods
    // happens every step
}
generated quantities {
    // more things we want the posterior distribution of
    // but that don't affect the random walk
}
```

## On priors

Under the hood,
```
    z ~ poisson(mu);
```
is equivalent to
```
    target += poisson_lpdf(z | mu);
```
(`lpdf` = log posterior density function).

. . .

So, if you *don't* put a prior on something,
it implicitly has a *uniform* prior (i.e., a flat prior).

## Error messages

These are important.
Pay attention to them, and fix the problems.

. . .

Run code in the *console*.
Rstudio often hides useful information.


## Parameterization matters

More on this later.


# Including overdispersion

## How can we include overdispersion?


::: {.columns}
::::::::: {.column width="50%"}


1. Counts are **Poisson**,

2. with mean that depends on age and exposure,

3. but effect of exposure depends on genotype.

4. Actually, counts are *overdispersed*, so make the means *random*,
   and lognormally distributed.

:::
:::::::::: {.column width="50%"}


$$\begin{aligned}
    Z_i &\sim \Poisson(\mu_i) \\
    \mu_i &= \exp\left( a_{g_i} + b \times \text{age}_i + c_{g_i} \times \text{exposure}_i \right)
\end{aligned}$$

:::
:::::::::::


--------------------


::: {.columns}
::::::::: {.column width="50%"}


1. Counts are **Poisson**,

2. with mean that depends on age and exposure,

3. but effect of exposure depends on genotype.

4. Actually, counts are *overdispersed*, so the means are *random*,
   and lognormally distributed.

:::
:::::::::: {.column width="50%"}

$$\begin{aligned}
    Z_i &\sim \Poisson(\mu_i) \\
    \mu_i &= \exp(W_i) \\
    W_i &\sim \Normal(y_i, \sigma) \\
    y_i &= a_{g_i} + b \times \text{age}_i + c_{g_i} \times \text{exposure}_i
\end{aligned}$$

:::
:::::::::::


--------------------


::: {.columns}
::::::::: {.column width="50%"}


1. Counts are **Poisson**,

2. with mean that depends on age and exposure,

3. but effect of exposure depends on genotype.

4. Actually, counts are *overdispersed*, so the means are *random*,
   and lognormally distributed.

:::
:::::::::: {.column width="50%"}


$$\begin{aligned}
    Z_i &\sim \Poisson(\mu_i) \\
    \mu_i &\sim \log\Normal(y_i, \sigma) \\
    y_i &= a_{g_i} + b \times \text{age}_i + c_{g_i} \times \text{exposure}_i 
\end{aligned}$$

:::
:::::::::::

## Add overdispersion

::: {.columns}
::::::::: {.column width="40%"}


$$\begin{aligned}
    Z_i &\sim \Poisson(\mu_i) \\
    \mu_i &\sim \log\Normal(y_i, \sigma) \\
    y_i &= a_{g_i} + b \times \text{age}_i \\
    &\qquad {} + c_{g_i} \times \text{exposure}_i 
\end{aligned}$$


:::
:::::::::: {.column width="60%"}

```
overdispersed_model <- stan_model(model_code="
data {
    int N; // number of data points
    vector[N] age;
    vector[N] exposure;
    int counts[N];
    int genotype[N];
    int ngenotypes;
}
parameters {
    vector[ngenotypes] a; // intercepts
    real b; // slope for age
    vector[ngenotypes] c; // slopes for exposure
    real<lower=0> sigma; // SD on lognormal
    vector[N] mu; // mean of the poissons
}
model {
    vector[N] y; // mean of the lognormals
    y = a[genotype] + b * age + c[genotype] .* exposure;
    mu ~ lognormal(y, sigma);
    counts ~ poisson(mu);
    a ~ normal(0, 100);
    b ~ normal(0, 10);
    c ~ normal(0, 20);
    sigma ~ normal(0, 10);
}")
```

:::
:::::::::::

---------------

```{r fit_fullmodel, cache=TRUE, dependson="sim_counts"}
fit2 <- stan(file="lognormal_poisson.stan",
             data=scaled_data,
             iter=1000, chains=3)
```

----------------

```{r print_fullmodel}
post2 <- rstan::extract(fit2)
print(fit2)
```


----------------

```{r trace_fullmodel}
stan_trace(fit2, pars=c("a", "b", "c", "sigma", "lp__"))
```


## How'd we do *now*?

Here are posterior distributions from the full model,
with the true values in red.
```{r true_fit, echo=FALSE}
# a[g] + b * (age - ma)/sa + c[g] * (exp - me)/se
# = a[g] - b * ma / sa - c[g] * me / se + (b/sa) * age  + (c[g]/se) * exp
layout(matrix(1:6, nrow=2, byrow=TRUE))
with(data, {
    hist(post2$a[,1] - post2$b * mean(age)/sd(age) - post2$c[,1] * mean(exposure)/sd(exposure), 
         breaks=50, main='a[1]')
    abline(v=true_params$a[1], col='red', lwd=2)
    hist(post2$a[,2] - post2$b * mean(age)/sd(age) - post2$c[,2] * mean(exposure)/sd(exposure), 
         breaks=50, main='a[2]')
    abline(v=true_params$a[2], col='red', lwd=2)
    hist(post2$b/sd(age), breaks=50, main='b')
    abline(v=true_params$b, col='red', lwd=2)
    hist(post2$c[,1]/sd(exposure), breaks=50, main='c[1]')
    abline(v=true_params$c[1], col='red', lwd=2)
    hist(post2$c[,2]/sd(exposure), breaks=50, main='c[2]')
    abline(v=true_params$c[2], col='red', lwd=2)
    hist(post2$sigma, breaks=50, main='sigma')
    abline(v=true_params$sigma, col='red', lwd=2)
 })
```


## Posterior predictive simulations, again


::: {.columns}
:::::::: {.column width="60%"}

```{r post_sims2}
# 100 datasets:
params2 <- list(a=colMeans(post2$a),
                b=mean(post2$b),
                c=colMeans(post2$c),
                sigma=mean(post2$sigma))
y2 <- with(list2env(scaled_data), 
                params2$a[geno] 
                    + params2$b * age
                    + params2$c[geno] * expo)
sim2 <- replicate(100, {
           mu = exp(rnorm(length(y2),
                          mean=y2, 
                          sd=params2$sigma))
           rpois(length(mu), mu)
         })
```

:::
:::::::::: {.column width="40%"}

```
model {
    vector[N] y;
    y = a[geno] + b * age + c[geno] .* expo;
    mu ~ lognormal(y, sigma);
    counts ~ poisson(mu);
}
```

:::
:::::::::::

## Now we cover the true data

```{r plot_post_sims2}
plot(data$counts[order(mu1)], ylab="counts", ylim=range(sim2), type='n')
segments(x0=seq_len(nrow(data)),
         y0=rowMins(sim2)[order(mu1)],
         y1=rowMaxs(sim2)[order(mu1)])
points(data$counts[order(mu1)], pch=20, col='red')
legend("topleft", pch=c(20,NA), lty=c(NA,1), legend=c("observed", "simulated range"), col=c('red', 'black'))
```


## Now we cover the true data

```{r plot_post_sims3}
plot(data$counts[order(mu1)], ylab="counts", ylim=c(0,500), type='n')
segments(x0=seq_len(nrow(data)),
         y0=rowMins(sim2)[order(mu1)],
         y1=rowMaxs(sim2)[order(mu1)])
points(data$counts[order(mu1)], pch=20, col='red')
legend("topleft", pch=c(20,NA), lty=c(NA,1), legend=c("observed", "simulated range"), col=c('red', 'black'))
```

